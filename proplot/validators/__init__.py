#!/usr/bin/env python3
"""
Various custom validators.
"""
import re
import numpy as np
from numbers import Integral, Number
from matplotlib import rcParams

LOCS_MAP = {
    'inset': 'best',
    'i': 'best',
    0: 'best',
    1: 'upper right',
    2: 'upper left',
    3: 'lower left',
    4: 'lower right',
    5: 'center left',
    6: 'center right',
    7: 'lower center',
    8: 'upper center',
    9: 'center',
    'l': 'left',
    'r': 'right',
    'b': 'bottom',
    't': 'top',
    'c': 'center',
    'ur': 'upper right',
    'ul': 'upper left',
    'll': 'lower left',
    'lr': 'lower right',
    'cr': 'center right',
    'cl': 'center left',
    'uc': 'upper center',
    'lc': 'lower center',
}

UNITS_MAP = {
    'in': 1.0,
    'm': 39.37,
    'ft': 12.0,
    'cm': 0.3937,
    'mm': 0.03937,
    'pt': 1 / 72.0,
    'pc': 1 / 6.0,
}

REGEX_NUMBER = re.compile(
    r'\A([-+]?[0-9._]+(?:[eE][-+]?[0-9_]+)?)(.*)\Z'
)


def _get_units_map(axes=None, figure=None, width=True):
    """
    Return units dictionary from the current params.
    """
    # Font unit scales
    # NOTE: Delay font_manager import, because want to avoid rebuilding font
    # cache, which means import must come after TTFPATH added to environ
    # by styletools.register_fonts()!
    small = rcParams['font.size']  # must be absolute
    large = rcParams['axes.titlesize']
    if isinstance(large, str):
        # Scaling must be valid because rcParams assignments are validated!
        import matplotlib.font_manager as mfonts
        scale = mfonts.font_scalings[large]
        large = small * scale

    # Scales for converting physical units to inches
    units_map = {
        'em': small / 72.0,
        'en': 0.5 * small / 72.0,
        'Em': large / 72.0,
        'En': 0.5 * large / 72.0,
        'ly': 3.725e+17,
    }

    # Scales for converting display units to inches
    # WARNING: In ipython shell these take the value 'figure'
    if not isinstance(rcParams['figure.dpi'], str):
        # once generated by backend
        units_map['px'] = 1 / rcParams['figure.dpi']
    if not isinstance(rcParams['savefig.dpi'], str):
        # once 'printed' i.e. saved
        units_map['pp'] = 1 / rcParams['savefig.dpi']

    # Scales relative to axes and figure objects
    if axes is not None and hasattr(axes, 'get_size_inches'):  # proplot axes
        units_map['ax'] = axes.get_size_inches()[1 - int(width)]
    if figure is None:
        figure = getattr(axes, 'figure', None)
    if figure is not None and hasattr(
            figure, 'get_size_inches'):  # proplot axes
        units_map['fig'] = figure.get_size_inches()[1 - int(width)]
    return units_map


def _validate_abcstyle(s):
    """Validate the a-b-c style."""
    if not isinstance(abcstyle, str):
        raise ValueError(f'Invalid abcstyle {abcstyle!r}. Must be string.')
    acount = abcstyle.count('a')
    Acount = abcstyle.count('A')
    if acount > 1 or Acount > 1:
        raise ValueError(f'Invalid abcstyle {abcstyle!r}. Too many a\'s.')
    elif acount == 0 and Acount == 0:
        raise ValueError(
            f'Invalid abcstyle {abcstyle!r}. '
            'Must include letter "a" or "A".'
        )
    return s


def _validate_loc(s, default=None, invalid=None, allow_custom=False):
    """
    Validate the requested location for a title, a-b-c label, colorbar, or
    legend.

    Parameters
    ----------
    s : None, str, or int, optional
        The location.
    default : optional
        The default location used if `s` is ``None``. If this is also ``None``
        an error will be raised.
    allow_custom : bool, optional
        Whether to allow custom locations. This is currently only possible
        for legends.
    invalid : list of str, optional
        Additional invalid locations. This is used to interpret title and
        a-b-c label locations.
    """
    # Apply filter and get message
    invalid = invalid or ()
    locs = {
        key: value for key, value in LOCS_MAP.items() if value not in invalid
    }
    msg = (
        f'Invalid location {s!r}. Options are: '
        ', '.join(map(repr, set(locs.keys()) | set(locs.values()))) + '.'
    )

    # Convert location to standardized form
    if s in (None, True):
        if default is None:  # occurs during rc assignments
            raise ValueError(msg)
        else:
            return default  # should be sentinel, or already validated value
    elif isinstance(s, (str, Integral)):
        if s in locs.values():  # full name
            pass
        else:
            try:
                s = locs[s]
            except KeyError:
                raise ValueError(msg)
    elif allow_custom and np.iterable(s) and len(s) == 2 and all(
        isinstance(l, Number) for l in s
    ):
        s = np.array(s)
    else:
        raise ValueError(msg)
    return s


def _validate_legend_loc(s, **kwargs):
    """Validate legend location."""
    return _validate_loc(s)


def _validate_colorbar_loc(s, **kwargs):
    """Validate colorbar location."""
    kwargs.setdefault('allow_custom', False)
    kwargs.setdefault('invalid', (
        'center', 'best'
        'center right', 'center left', 'lower center', 'upper center'
    ))
    return _validate_loc(s, **kwargs)


def _validate_title_loc(s, **kwargs):
    """Validate colorbar location."""
    kwargs.setdefault('allow_custom', False)
    kwargs.setdefault('invalid', (
        'center', 'best'
        'center right', 'center left', 'lower center', 'upper center'
    ))
    return _validate_loc(s, **kwargs)


def _validate_units(s, prefix=None, convert=False, **kwargs):
    """
    Validate arguments interpreted by units function. Optionally delay
    conversion until later in case the units depend on rcParams.

    Parameters
    ----------
    s : str or float, optional
        The value.
    prefix : str, optional
        The error message prefix. This is overridden by `units`.
    convert : bool, optional
        Whether to convert the result.
    **kwargs
        Passed to `_get_units_map`.
    """
    # Numbers or None
    # TODO: Reconsider permitting None input for all units() calls?
    prefix = prefix or f'Invalid size spec {s!r}.'
    msg = '{prefix} Must be string or number.'
    if s is None and not convert:  # None only allowed for units() calls
        raise ValueError(msg)
    elif s is None or isinstance(s, Number):
        return s
    elif not isinstance(s, str):
        raise ValueError(msg)

    # Interpret units
    regex = REGEX_NUMBER.match(s)
    units_map = _get_units_map(**kwargs)
    msg = (
        f'{prefix} Valid units are: '
        + ', '.join(map(repr, units_map.keys())) + '.'
    )
    if not regex:
        raise ValueError(msg)
    number, units = regex.groups()
    try:
        value = float(number) * (units_map[units] if units else 1)
    except (KeyError, ValueError):
        raise ValueError(msg)

    # Delay conversion until later for custom rcparams so they are affected
    # by e.g. font size changes
    if convert:
        return value
    else:
        return s

def _ValidateInList(options):
    """Verify an object is in some list."""
    def _validator(s, options=options):
        if isinstance(s, str):
            s = s.lower()
        if s in options:
            return s
        else:
            raise ValueError(
                f'Invalid value {s!r}. Options are: '
                + ', '.join(map(repr, options)) + '.'
            )
    return _validator

_validate_reso = _ValidateInList((
    'lo', 'med', 'hi'
))

_validate_fontweight = _ValidateInList((
    'ultralight', 'light', 'normal', 'regular', 'book',
    'medium', 'roman', 'semibold', 'demibold', 'demi',
    'bold', 'heavy', 'extra bold', 'black',
    100, 200, 400, 400, 400, 500, 500, 600, 600, 600, 700, 800, 800, 900
))
